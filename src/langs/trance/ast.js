'use strict';

const fs = require('fs');
const path = require('path');
const O = require('omikron');
const esolangs = require('../..');
const cs = require('./ctors');

const rules = {
  script: e => new cs.Program(e.es[1].arr),
  funcDef: e => new cs.FunctionDefinition(e.es[0].fst, e.es[2].fst.name, e.es[6].fst, e.es[10].fst),
  formalArgs: e => e.fst.arr,
  formalArg: e => new cs.FormalArgument(e.es[0].fst, e.es[2].fst.name),
  funcBody: e => e.fst.fst,
  stat: e => e.fst.fst,
  statOrVarDef: e => e.fst.fst,
  varDef: e => new cs.VariableDefinition(e.es[0].fst, e.es[2].fst.name, e.es[6].fst),
  block: e => new cs.CodeBlock(e.es[2].arr),
  ret: e => new cs.Return(e.es[2].fst),
  control: e => e.fst.fst,
  if: e => e.fst.fst,
  else: e => e.fst.fst,
  for: e => e.fst.fst,
  while: e => e.fst.fst,
  e: e => e.fst.fst,
  e1_: e => e.fst.fst,
  e3_: e => e.fst.fst,
  e4_: e => e.fst.fst,
  e5_: e => e.fst.fst,
  e6_: e => e.fst.fst,
  e8_: e => e.fst.fst,
  e9_: e => e.fst.fst,
  e10_: e => e.fst.fst,
  e11_: e => e.fst.fst,
  e12_: e => e.fst.fst,
  e13_: e => e.fst.fst,
  e14_: e => e.fst.fst,
  e15_: e => e.fst.fst,
  e17_: e => e.fst.fst,
  e18_: e => e.fst.fst,
  e20_: e => e.fst.fst,
  e21_: e => e.fst.fst,
  e1: e => e.fst.fst,
  e3: e => e.fst.fst,
  e4: e => e.fst.fst,
  e5: e => e.fst.fst,
  e6: e => e.fst.fst,
  e8: e => e.fst.fst,
  e9: e => e.fst.fst,
  e10: e => e.fst.fst,
  e11: e => e.fst.fst,
  e12: e => e.fst.fst,
  e13: e => e.fst.fst,
  e14: e => e.fst.fst,
  e15: e => e.fst.fst,
  e17: e => e.fst.fst,
  e18: e => e.fst.fst,
  e20: e => e.fst.fst,
  e21: e => e.fst.fst,
  comma: e => e.fst.fst,
  assign: e => e.fst.fst,
  cond: e => e.fst.fst,
  lOr: e => e.fst.fst,
  lAnd: e => e.fst.fst,
  bOr: e => e.fst.fst,
  bXor: e => e.fst.fst,
  bAnd: e => e.fst.fst,
  equal: e => e.fst.fst,
  cmp: e => e.fst.fst,
  shift: e => e.fst.fst,
  addSub: e => e.fst.fst,
  mulDivMod: e => e.fst.fst,
  unaryPre: e => e.fst.fst,
  unaryPost: e => e.fst.fst,
  index: e => e.fst.fst,
  call: e => e.fst.fst,
  group: e => e.fst.fst,
  assignOp: e => e.fst.fst,
  lOrSep: e => e.fst.fst,
  lAndSep: e => e.fst.fst,
  eqOp: e => e.fst.fst,
  cmpOp: e => e.fst.fst,
  shiftOp: e => e.fst.fst,
  addSubOp: e => e.fst.fst,
  mulDivModOp: e => e.fst.fst,
  unaryPreOp: e => e.fst.fst,
  unaryPostOp: e => e.fst.fst,
  type: e => new cs.Type(e.es[0].fst, e.es[2].fst),
  typeName: e => e.str,
  ptrs: e => e.fst.arr.length,
  ident: e => new cs.Identifier(e.str),
  literal: e => e.fst.fst,
  int: e => new cs.Integer(BigInt(e.str)),
  commaSep: e => e.fst.fst,
  whitespace: e => e.fst.fst,
  comment: e => e.fst.fst,
  inlineComment: e => e.fst.fst,
  multilineComment: e => e.fst.fst,
  s: e => e.fst.fst,
  s0: e => e.fst.fst,
  s1: e => e.fst.fst,
};

module.exports = rules;